"use strict";function Commlink(crypto){let commlink={};"undefined"!=typeof window&&(crypto=window.crypto||crypto),commlink.crypto=crypto;const getSaltBits=(salt,length)=>{let saltBits=new Uint8Array(length);return salt&&(saltBits="string"==typeof salt?commlink.fromText(salt):salt),saltBits},getKeyBits=bits=>{let keyBits=bits;return"string"==typeof bits&&(keyBits=commlink.decode(bits)),keyBits};commlink.toHex=(byteArray=>Array.from(new Uint8Array(byteArray)).map(val=>("00"+val.toString(16)).slice(-2)).join("")),commlink.fromHex=(str=>new Uint8Array(str.match(/.{0,2}/g).map(val=>parseInt(val,16)))),commlink.encode=commlink.toB64=(byteArray=>btoa(Array.from(new Uint8Array(byteArray)).map(val=>String.fromCharCode(val)).join("")).replace(/\+/g,"-").replace(/\//g,"_").replace(/\=/g,"")),commlink.decode=commlink.fromB64=(str=>new Uint8Array(atob(str.replace(/\_/g,"/").replace(/\-/g,"+")).split("").map(val=>val.charCodeAt(0)))),commlink.fromText=(str=>textEncoder(str)),commlink.toText=(byteArray=>textDecoder(byteArray));const textEncoder=str=>new Uint8Array(str.split("").map(val=>val.charCodeAt(0))),textDecoder=bits=>Array.from(new Uint8Array(bits)).map(val=>String.fromCharCode(val)).join("");return commlink.combine=((bitsA=[],bitsB=[])=>{let A=bitsA,B=bitsB;"string"==typeof bitsA&&(A=commlink.decode(bitsA)),"string"==typeof bitsB&&(B=commlink.decode(bitsB));let a=new Uint8Array(A),b=new Uint8Array(B),c=new Uint8Array(a.length+b.length);return c.set(a),c.set(b,a.length),c}),commlink.getId=(async encodedBits=>commlink.toHex(await crypto.subtle.digest("SHA-256",commlink.decode(encodedBits))).slice(-16)),commlink.getPublic=(async(entity={})=>{let result={};return entity.id&&(result.id=entity.id),entity.uid&&(result.uid=entity.uid),entity.pub&&(result.pub=entity.pub),entity.msg&&(result.msg=entity.msg),entity.sig&&(result.sig=entity.sig),result}),commlink.random=(size=>crypto.getRandomValues(new Uint8Array(size))),commlink.randomNumber=((digits,asString=!1)=>{let num=commlink.random(2*digits).join("").slice(0,digits);return asString?num:parseInt(num)}),commlink.createECDH=(async(curve="P-256")=>{let DH=await crypto.subtle.generateKey({name:"ECDH",namedCurve:curve},!0,["deriveBits"]),pub=await crypto.subtle.exportKey("raw",DH.publicKey),key=commlink.encode(await crypto.subtle.exportKey("pkcs8",DH.privateKey));return{id:await commlink.getId(commlink.encode(pub)),pub:commlink.encode(pub),key:key}}),commlink.createECDSA=(async(curve="P-256")=>{let user=await crypto.subtle.generateKey({name:"ECDSA",namedCurve:curve},!0,["sign","verify"]),pub=await crypto.subtle.exportKey("raw",user.publicKey),key=commlink.encode(await crypto.subtle.exportKey("pkcs8",user.privateKey));return{id:await commlink.getId(commlink.encode(pub)),pub:commlink.encode(pub),key:key}}),commlink.createUser=(async(curve="P-256")=>{let user=await commlink.createECDSA(curve||"P-256");return user.sig=await commlink.sign(user.key,user.pub),user}),commlink.sign=(async(key,msg,curve="P-256")=>{let message=JSON.stringify(msg),signKey=await crypto.subtle.importKey("pkcs8",commlink.decode(key),{name:"ECDSA",namedCurve:curve},!1,["sign"]),sig=await crypto.subtle.sign({name:"ECDSA",hash:"sha-256"},signKey,textEncoder(message));return commlink.encode(sig)}),commlink.verify=(async(pub,sig,msg,curve="P-256")=>{let message=JSON.stringify(msg),verifyKey=await crypto.subtle.importKey("raw",commlink.decode(pub),{name:"ECDSA",namedCurve:curve},!1,["verify"]);return await crypto.subtle.verify({name:"ECDSA",hash:"sha-256"},verifyKey,commlink.decode(sig),textEncoder(message))}),commlink.hmacSign=(async(key,msg)=>{let message=JSON.stringify(msg),hmacKey=await crypto.subtle.importKey("raw",commlink.decode(key),{name:"HMAC",hash:"SHA-256"},!1,["sign"]),sig=await crypto.subtle.sign({name:"HMAC",hash:"SHA-256"},hmacKey,textEncoder(message));return commlink.encode(sig)}),commlink.hmacVerify=(async(key,sig,msg)=>{let message=JSON.stringify(msg),verifyKey=await crypto.subtle.importKey("raw",commlink.decode(key),{name:"HMAC",hash:"SHA-256"},!1,["verify"]);return await crypto.subtle.verify({name:"HMAC",hash:"sha-256"},verifyKey,commlink.decode(sig),textEncoder(message))}),commlink.pbkdf2=(async(bits,salt=null,size=256,iterations=1,hashAlg="SHA-256")=>{let keyBits=getKeyBits(bits),saltBits=getSaltBits(salt,keyBits.length),key=await crypto.subtle.importKey("raw",keyBits,{name:"PBKDF2"},!1,["deriveBits"]),result=await crypto.subtle.deriveBits({name:"PBKDF2",salt:saltBits,iterations:iterations,hash:hashAlg},key,size);return commlink.encode(result)}),commlink.hkdf=(async(bits,salt=null,info="",size=256,hashAlg="SHA-256")=>{let keyBits=getKeyBits(bits),saltBits=getSaltBits(salt,keyBits.length),infoBits=commlink.fromText(info||""),key=await crypto.subtle.importKey("raw",keyBits,{name:"HKDF"},!1,["deriveBits"]),result=await crypto.subtle.deriveBits({name:"HKDF",salt:saltBits,info:infoBits,hash:hashAlg},key,size);return commlink.encode(result)}),commlink.ecdh=(async(key,pub,curve="P-256",size=256)=>{let pubKey=await crypto.subtle.importKey("raw",commlink.decode(pub),{name:"ECDH",namedCurve:curve},!0,[]),privateKey=await crypto.subtle.importKey("pkcs8",commlink.decode(key),{name:"ECDH",namedCurve:curve},!0,["deriveBits"]),shared=await crypto.subtle.deriveBits({name:"ECDH",public:pubKey},privateKey,size);return commlink.encode(shared)}),commlink.link=(async(key,pub,curve="P-256",size=256)=>{let pubKey=await crypto.subtle.importKey("raw",commlink.decode(pub),{name:"ECDH",namedCurve:curve},!0,[]),privateKey=await crypto.subtle.importKey("pkcs8",commlink.decode(key),{name:"ECDH",namedCurve:curve},!0,["deriveBits"]),shared=await crypto.subtle.deriveBits({name:"ECDH",public:pubKey},privateKey,size),bits=commlink.encode(shared);return{id:await commlink.getId(bits),bits:bits}}),commlink.chain=(async(bits,info="",size=10,alg="hkdf")=>{let keyBits=bits;"string"==typeof bits&&(keyBits=commlink.decode(bits));let chain=[],dBits=null;dBits="pbkdf2"===alg?await commlink.pbkdf2(keyBits,commlink.fromText(info||""),256*parseInt(size)):await commlink.hkdf(keyBits,null,info||"",256*parseInt(size));let arrayBits=Array.from(commlink.decode(dBits));for(let i=0;i<size;i++){let cell=arrayBits.splice(0,32);await commlink.getId(commlink.encode(cell));chain.push(commlink.encode(cell))}return chain}),commlink.encrypt=(async(msg={},bits=null,iterations=1e5)=>{let keyBits=getKeyBits(bits),message=JSON.stringify(msg),data=textEncoder(message),salt=crypto.getRandomValues(new Uint8Array(keyBits.length)),secret=commlink.decode(await commlink.pbkdf2(keyBits,salt,512,parseInt(iterations))),iv=secret.slice(0,12),secretKey=await crypto.subtle.importKey("raw",secret.slice(32,64),{name:"AES-GCM"},!1,["encrypt"]),encrypted=await crypto.subtle.encrypt({name:"AES-GCM",iv:iv},secretKey,data),it=textEncoder(iterations.toString());return commlink.toB64(it)+"."+commlink.toB64(salt)+"."+commlink.toB64(encrypted)}),commlink.decrypt=(async(payload=null,bits=null)=>{let keyBits=getKeyBits(bits),parts=payload.split("."),iterations=parseInt(textDecoder(commlink.fromB64(parts[0]))),salt=commlink.fromB64(parts[1]),data=commlink.fromB64(parts[2]),secret=commlink.decode(await commlink.pbkdf2(keyBits,salt,512,iterations)),iv=secret.slice(0,12),secretKey=await crypto.subtle.importKey("raw",secret.slice(32,64),{name:"AES-GCM"},!1,["decrypt"]),decrypted=await crypto.subtle.decrypt({name:"AES-GCM",iv:iv},secretKey,data).catch(err=>!1);return decrypted?JSON.parse(textDecoder(decrypted)):Promise.reject({message:"Failed to decrypt message."})}),commlink.exporter=(async(item,password,iterations=1e5)=>{return await commlink.encrypt(JSON.stringify(item),textEncoder(password),iterations)}),commlink.importer=(async(encrypted,password)=>{let decrypted=await commlink.decrypt(encrypted,textEncoder(password));return JSON.parse(decrypted)}),commlink.test=(async(params={})=>{let{chainAlg:chainAlg,chainSize:chainSize,iterations:iterations}=params,alice={};alice.id=await commlink.createUser(),alice.pub=await commlink.getPublic(alice.id);let bob={};bob.id=await commlink.createUser(),bob.pub=await commlink.getPublic(bob.id),alice.link=await commlink.ecdh(alice.id.key,bob.pub.pub),bob.link=await commlink.ecdh(bob.id.key,alice.pub.pub);let link=await commlink.link(bob.id.key,alice.pub.pub);return alice.bits=await commlink.pbkdf2(alice.link,null,256,iterations||1),bob.bits=await commlink.pbkdf2(bob.link,null,256,iterations||1),alice.chain=await commlink.chain(alice.bits,"",chainSize||10,chainAlg||null),bob.chain=await commlink.chain(bob.bits,"",chainSize||10,chainAlg||null),alice.toBob=await commlink.encrypt("Hello, Bob. I'm Alice.",alice.chain[0],iterations||1),bob.toAlice=await commlink.encrypt("Hi, Alice. I am Bob.",bob.chain[0],iterations||1),alice.fromBob=await commlink.decrypt(bob.toAlice,alice.chain[0]),bob.fromAlice=await commlink.decrypt(alice.toBob,bob.chain[0]),alice.exported=await commlink.exporter(alice,"alicepassword",iterations||1),bob.exported=await commlink.exporter(bob,"bobpassword",iterations||1),alice.imported=await commlink.importer(alice.exported,"alicepassword"),bob.imported=await commlink.importer(bob.exported,"bobpassword"),{alice:alice,bob:bob,link:link}}),commlink}"undefined"!=typeof module&&module&&module.exports&&(module.exports=Commlink);